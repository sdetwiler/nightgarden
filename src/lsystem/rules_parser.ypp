%name-prefix="rules_"
%pure-parser
%error-verbose
%lex-param { yyscan_t scanner }
%parse-param { yyscan_t scanner }
%parse-param { LSystem* lsystem }

%{

typedef void* yyscan_t;
union YYSTYPE;
extern int rules_lex(YYSTYPE* yylval_param ,yyscan_t yyscanner);

#include <stdio.h>
#include <string.h>

#include "types.h"
#include "predicate.h"
#include "lsystem.h"

// #define DEBUG_PARSER

int rules_error(yyscan_t scanner, LSystem* lsystem, const char* msg) {
	std::cout << "Rules: " << msg << std::endl;
	return 0;
}

%}

%union {
	class Rule*           rule;
	class Predicate*      predicate;
	class Result*         result;
	class SymbolList*     symbolList;
	class Symbol*         symbol;
	class VariableList*   variableList;
	class Variable*       variable;
	class ExpressionList* expressionList;
	class Expression*     expression;

	float                 num_float;
	char*                 str;
}

%token <num_float>   FLOAT
%token <symbol>      SYMBOL
%token <variable>    VARIABLE
%token <str>         STRING

%token COMMENT

%token TRANSITION
%token COLON
%token COMMA

%token LP
%token RP

%token ADD
%token SUB
%token EXP

%token LT
%token LTE
%token GT
%token GTE
%token EQ
%token NEQ

%token NEWLINE
%token AXIOM
%token STATE
%token RULE
%token VAR

%type <variable>        variable_dec
%type <variable>        variable
%type <rule>            rule
%type <predicate>       predicate
%type <predicate>       predicate_symbols
%type <result>          result
%type <symbol>          symbol
%type <symbolList>      symbol_list
%type <symbol>          result_symbol
%type <symbol>          symbol_with_vars
%type <symbol>          symbol_operator_with_expr
%type <symbol>          symbol_operator
%type <symbolList>      result_symbol_list
%type <variableList>    variable_list
%type <expression>		condition_expr
%type <expression>      expr
%type <expressionList>  expr_list
%type <str>             operator
%type <num_float>		number

%destructor { delete $$; } SYMBOL




%%

start : statement
	| start statement

statement : rule eol
	| axiom eol
	| state eol
	| variable_dec eol
	| NEWLINE
	| COMMENT


axiom :
	AXIOM result
	{
		#ifdef DEBUG_PARSER
		printf("axiom %s\n", $2->toString().c_str());
		#endif
		
		lsystem->setAxiom($2);
	}

state :
	STATE result
	{
		#ifdef DEBUG_PARSER
		printf("state %s\n", $2->toTimedString().c_str());
		#endif
		
		lsystem->setState($2);
	}


variable_dec :
	VAR variable number
	{
		$$ = $2;
		$$->value = $3;

		#ifdef DEBUG_PARSER
		printf("variable_dec to VAR variable number\n\t%s %f\n", $2->toString().c_str(), $3);
		#endif

		lsystem->addGlobalVariable($$);
	}
	| VAR variable STRING
	{
		$$ = $2;
		$$->stringValue = $3;
		$$->type = Variable::String;
		#ifdef DEBUG_PARSER
		printf("variable_dec to VAR variable STRING\n\t%s %f\n", $2->toString().c_str(), $3);
		#endif
		
		lsystem->addGlobalVariable($$);
	}


variable :
	symbol_list
	{
		$$ = new Variable();
		$$->name = $1->toString();

		#ifdef DEBUG_PARSER
		printf("variable to symbol_list\n\t%s\n", $$->toString().c_str());
		#endif
	}

number :
	FLOAT
	{
		$$=$1;
		#ifdef DEBUG_PARSER
		printf("number to FLOAT\n\t%f\n", $$);
		#endif
	}
	| ADD FLOAT
	{
		$$=$2;

		#ifdef DEBUG_PARSER
		printf("number to ADD FLOAT\n\t%f\n", $$);
		#endif
	}
	| SUB FLOAT
	{
		$$=-$2;
		#ifdef DEBUG_PARSER
		printf("number to SUB FLOAT\n\t%f\n", $$);
		#endif
	}

rule :
	RULE predicate TRANSITION result
	{
		#ifdef DEBUG_PARSER
		printf("rule to RULE predicate TRANSITION result\n%s -> %s\n", $2->symbol->value.c_str(), $4->symbolList->toString().c_str());
		#endif
		
		$$ = new Rule();
		$$->predicate = $2;
		$$->result = $4;
		
		lsystem->addRule($$);
	}

predicate :
	predicate_symbols condition_expr
	{
		#ifdef DEBUG_PARSER
		printf("predicate to predicate_symbols condition_expr\n%s -> %s\n", $1->toString().c_str(), $2?$2->toString().c_str():"");
		#endif
		
		$$ = $1;
		$$->condition = $2;
	}

predicate_symbols :
	symbol
	{
		#ifdef DEBUG_PARSER
		printf("predicate_symbols to symbol\n\t%s\n", $1->value.c_str());
		#endif
		
		$$ = new Predicate(lsystem);
		$$->symbol = $1;
	}

	| symbol LT symbol
	{
		#ifdef DEBUG_PARSER
		printf("predicate_symbols to symbol LT symbol\n\t%s %s\n", $1->toString().c_str(), $3->toString().c_str());
		#endif
		
		$$ = new Predicate(lsystem);
		$$->prev = $1;
		$$->symbol = $3;
	}

	| symbol GT symbol
	{
		#ifdef DEBUG_PARSER
		printf("predicate_symbols to symbol GT symbol\n\t%s %s\n", $1->toString().c_str(), $3->toString().c_str());
		#endif
		
		$$ = new Predicate(lsystem);
		$$->symbol = $1;
		$$->next = $3;
	}

	| symbol LT symbol GT symbol
	{
		#ifdef DEBUG_PARSER
		printf("predicate_symbols to symbol LT symbol GT symbol\n\t%s %s %s\n", $1->toString().c_str(), $3->toString().c_str(), $5->toString().c_str());
		#endif
		
		$$ = new Predicate(lsystem);
		$$->prev = $1;
		$$->symbol = $3;
		$$->next = $5;
		
	}


condition_expr :
	/* empty */
	{
		$$ = nullptr;
	}
	| COLON expr
	{
		$$ = $2;
	}


variable_list :
	variable_list COMMA variable
	{
		#ifdef DEBUG_PARSER
		printf("variable_list to variable_list COMMA variable\n\tlist:[%s] variable:[%s]\n", $1->toString().c_str(), $3->toString().c_str());
		#endif

		$$->variables.push_back($3);
	}

	| variable
	{
		#ifdef DEBUG_PARSER
		printf("variable_list to variable\n\t%s\n", $1->toString().c_str());
		#endif
		
		$$ = new VariableList();
		$$->variables.push_back($1);
	}

symbol :
	symbol_with_vars
	{
		$$ = $1;
		
		#ifdef DEBUG_PARSER
		printf("symbol to symbol_with_vars\n\t%s\n", $$->toString().c_str());
		#endif
	}

	| SYMBOL
	{
		$$ = $1;
		
		#ifdef DEBUG_PARSER
		printf("symbol_with_vars to SYMBOL\n\tsymbol:%s\n", $$->toTimedString().c_str());
		#endif
	}


symbol_with_vars :
	SYMBOL LP variable_list RP
	{
		$$ = $1;
		$$->variables = $3;
		
		#ifdef DEBUG_PARSER
		printf("symbol_with_vars to SYMBOL LP variable_list RP\n\tsymbol:[%s] variable_list:[%s]\n", $$->toString().c_str(), $$->variables->toString().c_str());
		#endif
	}



/* Used to stitch symbols together into multi character variable names or expressions */
symbol_list :
	symbol_list SYMBOL
	{
		#ifdef DEBUG_PARSER
		printf("symbol_list to symbol_List SYMBOL\n\t%s\n", $2->value.c_str());
		#endif
		
		$$->symbols.push_back($2);
	}

	| SYMBOL
	{
		#ifdef DEBUG_PARSER
		printf("symbol_list to SYMBOL\n\t%s\n", $1->value.c_str());
		#endif
		
		$$ = new SymbolList();
		$$->symbols.push_back($1);
	}





result :
	result_symbol_list
	{
		#ifdef DEBUG_PARSER
		printf("result to result_symbol_list\n");
		#endif
		
		$$ = new Result();
		$$->symbolList = $1;
	}


result_symbol_list :
	result_symbol_list result_symbol
	{
		#ifdef DEBUG_PARSER
		printf("result_symbol_list to result_symbol_List result_symbol\n\t%s\n", $2->value.c_str());
		#endif
		
		$$->symbols.push_back($2);
	}

	| result_symbol
	{
		#ifdef DEBUG_PARSER
		printf("result_symbol_list to result_symbol\n\t%s\n", $1->value.c_str());
		#endif
		
		$$ = new SymbolList();
		$$->symbols.push_back($1);
	}


result_symbol :
	LP symbol_operator_with_expr COMMA number RP
	{
		$$ = $2;
		$$->age = $4;
		
		#ifdef DEBUG_PARSER
		printf("result_symbol to LP symbol_with_expr COMMA number RP\n\t%s\n", $$->toString().c_str());
		#endif
	}

	| LP symbol_operator_with_expr COMMA number COMMA number RP
	{
		$$ = $2;
		$$->age = $4;
		$$->terminalAge = $6;
		
		#ifdef DEBUG_PARSER
		printf("result_symbol to LP symbol_operator_with_expr COMMA number COMMA number RP\n\t%s\n", $$->toTimedString().c_str());
		#endif
	}

	| symbol_operator_with_expr
	{
		$$ = $1;

		#ifdef DEBUG_PARSER
		printf("result_symbol to symbol_operator_with_expr\n\t%s %s\n", $$->value.c_str());
		#endif
	}

symbol_operator_with_expr :
	symbol_operator LP expr_list RP
	{
		$$ = $1;
		$$->expressions = $3;
		
		#ifdef DEBUG_PARSER
		printf("symbol_operator_with_expr to symbol_operator LP expr_list RP\n\t%s %s\n", $$->value.c_str(), $3->toString().c_str());
		#endif
	}

	| symbol_operator
	{
		$$ = $1;
		
		#ifdef DEBUG_PARSER
		printf("result_symbol to symbol_operator\n\t%s\n", $$->value.c_str());
		#endif
	}


symbol_operator :
	SYMBOL
	{
		$$ = $1;

		#ifdef DEBUG_PARSER
		printf("symbol_operator to symbol\n\t%s\n", $$->value.c_str());
		#endif
	}

	| ADD
	{
		$$ = new Symbol();
		$$->value = "+";
		$$->isOperator = true;
		
		#ifdef DEBUG_PARSER
		printf("symbol_operator to ADD\n\tsymbol:[%s]\n", $$->toString().c_str());
		#endif
	}
	| SUB
	{
		$$ = new Symbol();
		$$->value = "-";
		$$->isOperator = true;
		
		#ifdef DEBUG_PARSER
		printf("symbol_operator to SUB\n\tsymbol:[%s]\n", $$->toString().c_str());
		#endif
	}
	| EXP
	{
		$$ = new Symbol();
		$$->value = "^";
		$$->isOperator = true;
		
		#ifdef DEBUG_PARSER
		printf("symbol_add_sub_exp to SUB\n\tsymbol:[%s]\n", $$->toString().c_str());
		#endif
	}




eol : NEWLINE

/* Really don't like this... */

expr_list :
	expr_list COMMA expr
	{
		#ifdef DEBUG_PARSER
		printf("expr_list to expr_list COMMA expr\n\t%s %s\n", $1->toString().c_str(), $3->toString().c_str());
		#endif


		$$->expressions.push_back($3);
	}
	| expr
	{
		#ifdef DEBUG_PARSER
		printf("expr_list to expr\n\t%s\n", $1->toString().c_str());
		#endif

		$$ = new ExpressionList();
		$$->expressions.push_back($1);
	}

expr :
	expr operator expr
	{
		#ifdef DEBUG_PARSER
		printf("expr to expr operator expr\n\t%s %s %s\n", $1->toString().c_str(), $2, $3->toString().c_str());
		#endif

		// Hrm...
		$$ = new Expression();
		(*$$)+= *$1;
		$$->value+= $2;
		(*$$)+= *$3;
		
		delete $1;
		free($2);
		delete $3;
	}

	| number
	{
		#ifdef DEBUG_PARSER
		printf("expr to number\n\t%f\n", $1);
		#endif

		$$ = new Expression();
		$$->value = std::to_string($1);
	}

	| symbol_list
	{
		$$ = new Expression();
		$$->value = $1->toString();

		#ifdef DEBUG_PARSER
		printf("expr to symbol_list\n\t%s\n", $1->toString().c_str());
		#endif
	}


operator :
	'*'
	{
		$$ = strdup("*");
	}

	| '/'
	{
		$$ = strdup("/");
	}
	| EXP
	{
		$$ = strdup("^");
	}

	| SUB
	{
		$$ = strdup("-");
	}

	| ADD
	{
		$$ = strdup("+");
	}
	| GT
	{
		$$ = strdup(">");
	}
	| LT
	{
		$$ = strdup("<");
	}
	| GTE
	{
		$$ = strdup(">=");
	}
	| LTE
	{
		$$ = strdup("<=");
	}
	| EQ
	{
		$$ = strdup("==");
	}
	| NEQ
	{
		$$ = strdup("!=");
	}


%%

%name-prefix="expression_"
%pure-parser
%error-verbose
%lex-param { yyscan_t scanner }
%parse-param { yyscan_t scanner }
%parse-param { VariableMap* scope }
%parse-param { Variable* retVal }

%{

typedef void* yyscan_t;
union YYSTYPE;
extern int expression_lex(YYSTYPE* yylval_param ,yyscan_t yyscanner);

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "types.h"
#include "lsystem.h"
// #define DEBUG_PARSER

int expression_error(yyscan_t scanner, VariableMap* scope, Variable* retVal, const char* msg) {
	cout << "Expression: " << msg << endl;
	return 0;
}
%}



%union {
	class Variable*  value;
	char*     identifier;
}

%token <value> INTEGER
%token <value> FLOAT
%token <identifier> IDENTIFIER

%token LT
%token LTE
%token GT
%token GTE
%token EQ
%token NEQ

%type <value> expr
%type <value> val

%destructor { free($$); } IDENTIFIER
%destructor { if($$) delete $$; } INTEGER
%destructor { if($$) delete $$; } FLOAT

%left '+' '-'
%left '*' '/'

%%

calc : expr
{
	if(retVal)
	{
		*retVal = *$1;
	}

	#ifdef DEBUG_PARSER
	printf("calc : expr\t%f\n", $1);
	#endif
	
}

expr : val { $$ = $1; }
| expr '*' expr { *$$ = *$1 * *$3; }
| expr '/' expr { *$$ = *$1 / *$3; }
| expr '+' expr { *$$ = *$1 + *$3; }
| expr '-' expr { *$$ = *$1 - *$3; }
| expr '^' expr { *$$ = pow($1->value, $3->value); }
| expr LT expr { *$$ = *$1 < *$3; }
| expr LTE expr { *$$ = *$1 <= *$3; }
| expr GT expr { *$$ = *$1 > *$3; }
| expr GTE expr { *$$ = *$1 >= *$3; }
| expr EQ expr { *$$ = *$1 == *$3; }
| expr NEQ expr { *$$ = *$1 != *$3; }

val :
	INTEGER
	{
		$$ = $1;
		#ifdef DEBUG_PARSER
		printf("INTEGER \t%f\n", $1);
		#endif
	}

	| FLOAT
	{
		$$ = $1;
		#ifdef DEBUG_PARSER
		printf("FLOAT \t%f\n", $1);
		#endif
	}

	| IDENTIFIER
	{
		Variable* v = nullptr;
		if(scope)
		{
			string k($1);
			StringVariableMap::iterator i = scope->variables.find(k);
			if(i!=scope->variables.end())
			{
				v = i->second;
			}
		}
		if(v)
		{
			$$ = new Variable(*v);
		}
		else
		{
			yyerror(scanner, scope, retVal, "Variable not defined");
		}
	}

%%

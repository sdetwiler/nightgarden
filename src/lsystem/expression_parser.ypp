%name-prefix="expression_"
%pure-parser
%lex-param { yyscan_t scanner }
%parse-param { yyscan_t scanner }
%parse-param { VariableMap* scope }
%parse-param { Variable* retVal }

%{

typedef void* yyscan_t;
union YYSTYPE;
extern int expression_lex(YYSTYPE* yylval_param ,yyscan_t yyscanner);

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "types.h"
#include "lsystem.h"

// #define DEBUG_PARSER

int expression_error(yyscan_t scanner, VariableMap* scope, Variable* retVal, const char* msg) {
	cout << "Expression: " << msg << endl;
	return 0;
}
%}



%union {
	float     value;
	char*     identifier;
}

%token <value> INTEGER
%token <value> FLOAT
%token <identifier> IDENTIFIER

%token LT
%token LTE
%token GT
%token GTE
%token EQ
%token NEQ

%type <value> expr
%type <value> number

%destructor { free($$); } IDENTIFIER

%left '+' '-'
%left '*' '/'

%%

calc : expr
{
	if(retVal)
	{
		retVal->value = $1;
	}
}

expr : number { $$ = $1; }
| expr '*' expr { $$ = $1 * $3; }
| expr '/' expr { $$ = $1 / $3; }
| expr '+' expr { $$ = $1 + $3; }
| expr '-' expr { $$ = $1 - $3; }
| expr '^' expr { $$ = pow($1, $3); }
| expr LT expr { $$ = $1 < $3; }
| expr LTE expr { $$ = $1 <= $3; }
| expr GT expr { $$ = $1 > $3; }
| expr GTE expr { $$ = $1 >= $3; }
| expr EQ expr { $$ = $1 == $3; }
| expr NEQ expr { $$ = $1 != $3; }

number : INTEGER { $$ = $1; }
| FLOAT { $$ = $1; }
| IDENTIFIER
{
	Variable* v = nullptr;
	if(scope)
	{
		string k($1);
		StringVariableMap::iterator i = scope->variables.find(k);
		if(i!=scope->variables.end())
		{
			v = i->second;
		}
	}
	if(v)
	{
		$$ = v->value;
	}
	else
	{
		yyerror(scanner, scope, retVal, "Variable not defined");
	}
}

%%

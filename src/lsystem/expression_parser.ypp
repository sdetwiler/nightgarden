%name-prefix="expression_"
%pure-parser
%error-verbose
%lex-param { yyscan_t scanner }
%parse-param { yyscan_t scanner }
%parse-param { VariableMap* scope }
%parse-param { Variable* retVal }

%{

typedef void* yyscan_t;
union YYSTYPE;
extern int expression_lex(YYSTYPE* yylval_param ,yyscan_t yyscanner);

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "types.h"
#include "lsystem.h"
// #define DEBUG_PARSER

int expression_error(yyscan_t scanner, VariableMap* scope, Variable* retVal, const char* msg) {
	std::cout << "Expression: " << msg << std::endl;
	return 0;
}
%}



%union {
	class Variable*  value;
	char*     identifier;
}

%token <value> INTEGER
%token <value> FLOAT
%token <identifier> IDENTIFIER

%token LT
%token LTE
%token GT
%token GTE
%token EQ
%token NEQ

%type <value> expr
%type <value> val

%destructor { printf("free IDENTIFIER Variable\n"); free($$); } IDENTIFIER
%destructor { printf("delete INTEGER Variable\n"); if($$) delete $$; } INTEGER
%destructor { printf("delete FLOAT Variable\n"); if($$) delete $$; } FLOAT

%left '+' '-'
%left '*' '/'

%%

calc : expr
{
	if(retVal)
	{
		std::string n = retVal->name;
		*retVal = *$1;
		retVal->name = n;
	}

	#ifdef DEBUG_PARSER
	printf("calc : expr\t%s\n", $1->toString().c_str());
	#endif
	
}
/* FIXME this is stupid */
expr : val { $$ = $1; }
| expr '*' expr { $$ = new Variable(); *$$ = *$1 * *$3; delete $1; delete $3; }
| expr '/' expr { $$ = new Variable(); *$$ = *$1 / *$3; delete $1; delete $3; }
| expr '+' expr { $$ = new Variable(); *$$ = *$1 + *$3; delete $1; delete $3; }
| expr '-' expr { $$ = new Variable(); *$$ = *$1 - *$3; delete $1; delete $3; }
| expr '^' expr { $$ = new Variable(); *$$ = pow($1->value, $3->value); delete $1; delete $3; }
| expr LT expr { $$ = new Variable(); *$$ = *$1 < *$3; delete $1; delete $3; }
| expr LTE expr { $$ = new Variable(); *$$ = *$1 <= *$3; delete $1; delete $3; }
| expr GT expr { $$ = new Variable(); *$$ = *$1 > *$3; delete $1; delete $3; }
| expr GTE expr { $$ = new Variable(); *$$ = *$1 >= *$3; delete $1; delete $3; }
| expr EQ expr { $$ = new Variable(); *$$ = *$1 == *$3; delete $1; delete $3; }
| expr NEQ expr { $$ = new Variable(); *$$ = *$1 != *$3; delete $1; delete $3; }

val :
	INTEGER
	{
		$$ = $1;
		#ifdef DEBUG_PARSER
		printf("INTEGER \t%s\n", $1->toString().c_str());
		#endif
	}

	| FLOAT
	{
		$$ = $1;
		#ifdef DEBUG_PARSER
		printf("FLOAT \t%s\n", $1->toString().c_str());
		#endif
	}

	| IDENTIFIER
	{
		std::string k($1);
		Variable* v = nullptr;
		if(scope)
		{
			StringVariableMap::iterator i = scope->variables.find(k);
			if(i!=scope->variables.end())
			{
				v = i->second;
			}
		}
		if(v)
		{
			$$ = new Variable(*v);
		}
		else
		{
			std::string msg = "Variable '" + k + "' is not defined";
			$$ = new Variable();
			yyerror(scanner, scope, retVal, msg.c_str());

		}
	}

%%
